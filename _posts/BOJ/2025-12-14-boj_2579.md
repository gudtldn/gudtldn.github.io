---
title: "BOJ 2579 - 계단 오르기 Rust 풀이"
description: "동적 계획법을 이용한 계단 오르기 문제 풀이"
categories:
  - BOJ
tags:
  - [boj, DP, rust]
toc: true
toc_sticky: true
math: true

date: 2025-12-14
last_modified_at: 2025-12-14
---

### 📚 추천 목차 구성

1. **문제 분석 (Problem Analysis)**
    * 문제의 핵심 조건과 목표 요약
2. **접근 방법 (Approach)**
    * 왜 DP를 선택했는지?
    * 문제 해결을 위한 핵심 아이디어 (뒤에서부터 생각하기 등)
3. **점화식 도출 (Recurrence Relation)**
    * DP 테이블 정의 ($DP[i]$의 의미)
    * 상태 전이 방정식 (수식 표현)
    * 초기값 설정 (Base Case)
4. **코드 구현 (Implementation)**
    * Rust 코드
5. **시행착오 및 배운 점 (Retrospective)**
    * 예외 처리($N=1, 2$)나 인덱스 주의할 점 등

## 1. 문제 분석

> [백준 2579 - 계단 오르기](https://www.acmicpc.net/problem/2579){:target="_blank"}

![그림 2](https://u.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/Screen%20Shot%202021-06-23%20at%203.01.39%20PM.png)

위 문제의 핵심 조건과 목표을 정리하면 다음과 같이 요약할 수 있습니다.

1. 계단은 **한 번에 한 계단씩** 또는 **두 계단씩** 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. **연속된 세 개의 계단을 모두 밟아서는 안 된다.** 단, 시작점은 계단에 포함되지 않는다.
3. **마지막 계단은 반드시 밟아야 한다.**

최종적으로 마지막 계단에 도달했을 때의 **점수 합의 최댓값을 구하는 것**이 목표입니다.

## 2. 접근 방법

이 문제는 동적 계획법(Dynamic Programming, DP)을 사용하여 해결할 수 있습니다.
<details markdown="1">
<summary>왜 DP를 선택했는가?</summary>
- 이 문제는 **이전 단계까지의 최적해(작은 문제)**를 이용하여 현재의 최적해(큰 문제)를 구할 수 있는 구조이므로, 계산 결과를 저장하고 재활용하는 DP가 가장 적합합니다.
</details>

### 2.1. 핵심 아이디어

<!-- markdownlint-disable-next-line blanks-around-headings -->
#### "도착지($N$)을 기준으로 역추적하기"
{: .text-center}

위 문제를 곰곰히 생각해보면, 마지막 계단($N$)에 도달하기 위해서는 두 가지 방법이 있음을 알 수 있습니다.

1. 전전 계단($N-2$)에서 점프: 2칸을 뛰었으므로 연속 3계단 규칙에 걸리지 않음.
2. 직전 계단($N-1$)에서 걷기: 규칙 위반(3연속)을 막기 위해, 그 전에는 반드시 **점프($N-3 \rightarrow N-1$)**해서 왔어야 함.

이를 바탕으로 다음과 같은 점화식을 도출할 수 있습니다.

$$
dp[i] = \max
\begin{cases}
dp[i-2] + score[i] & \text{(2칸 점프)} \\
dp[i-3] + score[i-1] + score[i] & \text{(직전 점프 후 1칸)}
\end{cases}
$$

## 3. 코드 구현

> 자세한 코드는 [여기](https://github.com/gudtldn/BOJ/blob/main/2579/rust/boj_2579/src/main.rs "GitHub - BOJ 2579 Rust 풀이"){:target="_blank"}에서 확인할 수 있습니다.

```rust
fn solution(stdin: &str) {
    let mut tokens = stdin.split_ascii_whitespace();

    // 계단 개수와 점수 입력
    let n: usize = tokens.next().unwrap().parse().unwrap();
    let stairs: Vec<u32> = tokens
        .map(|token| token.parse().unwrap())
        .collect();

    // 예외 처리: 계단이 1개 또는 2개인 경우
    if n == 1 {
        println!("{}", stairs[0]);
        return;
    } else if n == 2 {
        println!("{}", stairs[0] + stairs[1]);
        return;
    }

    // idx 번째 계단에 도달했을 때의 최대 점수
    let mut dp = vec![0; n];
    dp[0] = stairs[0];             // 계단이 1개일 때, 첫 번째 계단은 무조건 밟음
    dp[1] = stairs[0] + stairs[1]; // 계단이 2개일 때, 두 계단 모두 밟음

    // 계단이 3개일 때, 3번째 계단은 1번째 or 2번째 계단에서 올 수 있음
    dp[2] = (stairs[0] + stairs[2]).max(stairs[1] + stairs[2]);

    // 점화식에 따라 dp 배열 채우기
    for i in 3..n {
        // dp[i] = max(
        //     dp[i-2] + stairs[i],              // 2칸 점프
        //     dp[i-3] + stairs[i-1] + stairs[i] // 직전에 2칸 점프 후 1칸 점프
        // )
        dp[i] = (dp[i - 2] + stairs[i]).max(dp[i - 3] + stairs[i - 1] + stairs[i]);
    }

    // 마지막 계단에 도달했을 때의 최대 점수 출력
    println!("{}", dp[n - 1]);
}
```

## 4. 결론

~~ 대충 마무리하는 부분~~
