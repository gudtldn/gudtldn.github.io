---
title: "BOJ 2579 - 계단 오르기"
description: "동적 계획법을 이용한 계단 오르기 문제 풀이"
categories:
  - BOJ
tags:
  - [boj, DP, rust]
toc: true
toc_sticky: true

date: 2025-12-14
last_modified_at: 2025-12-14
---

## 문제 분석

> [백준 2579 - 계단 오르기](https://www.acmicpc.net/problem/2579)

~~대충 문제 설명하는 부분~~

## 접근 방법

~~ 대충 풀이 설명하는 부분~~
뒤에서부터 생각해보자. 마지막 계단에 도달하기 위해서는 두 가지 경우가 있다.

점화식 설명

## 코드 구현

> 자세한 코드는 [여기](https://github.com/gudtldn/BOJ/blob/main/2579/rust/boj_2579/src/main.rs)에서 확인할 수 있습니다.

```rust
fn solution(stdin: &str) {
    // 입력 파싱을 위한 매크로
    // macro_rules! parse_line {} ...

    // 계단 개수와 점수 입력
    let n = parse_line!(usize);
    let stairs = (0..n).map(|_| parse_line!(u32)).collect::<Vec<u32>>();

    if n == 1 {
        println!("{}", stairs[0]);
        return;
    } else if n == 2 {
        println!("{}", stairs[0] + stairs[1]);
        return;
    }

    // idx 번째 계단에 도달했을 때의 최대 점수
    let mut dp = vec![0; n];
    dp[0] = stairs[0];                                          // 1번째 계단은 무조건 밟음
    dp[1] = stairs[0] + stairs[1];                              // 2번째 계단도 무조건 밟음
    dp[2] = (stairs[0] + stairs[2]).max(stairs[1] + stairs[2]); // 3번째 계단은 1번째 or 2번째 계단에서 올 수 있음

    // 점화식에 따라 dp 배열 채우기
    for i in 3..n {
        // dp[i] = max(
        //     dp[i-2] + stairs[i],              // 2칸 점프
        //     dp[i-3] + stairs[i-1] + stairs[i] // 직전에 2칸 점프 후 1칸 점프
        // )
        dp[i] = (dp[i - 2] + stairs[i]).max(dp[i - 3] + stairs[i - 1] + stairs[i]);
    }

    // 마지막 계단에 도달했을 때의 최대 점수 출력
    println!("{}", dp[n - 1]);
}
```

## 결론

~~ 대충 마무리하는 부분~~
